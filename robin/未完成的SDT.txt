List<String> irCode;

class Statement{
int compare=-1;
int code1=-1;
int code2=-1;
int next=-1;
List<int> compareSentences;
List<int> code1Sentences;
List<int> code2Sentences;
List<int> nextSentences;
    void packpatch(){
        for(auto i:compareSentences)
            irCode[i]=fmt::format(irCode[i],compare);     
        for(auto i:code1Sentences)
            irCode[i]=fmt::format(irCode[i],code1);
        for(auto i:code2Sentences)
            irCode[i]=fmt::format(irCode[i],code2);
        for(auto i:nextSentences)
            irCode[i]=fmt::format(irCode[i],next);
    }
};

class Expression{
    int right;
    List<int>rightSentences;
    void packpatch()
    {
        for(auto i:rightSentences)
            irCode[i]=fmt::format(irCode[i],rightSentences);
    }
}

stack<Statement> currentStmt;
stack<Expression> currentExpr;

String genT(){
    static int Tindex=0;
    return fmt::format("T{}", Tindex++);
}

class Variable{
    int width;
    int offset;
    Type type;
    String name;
    Object value;
};

List<Variable> top;



0 S::program

1 program::declarations

2 declarations1::declaration declarations2
                 {
                  declarations1.returnType=declarations2.returnType;
                 }


3 declarations::ε

4 declaration::funDecl

5 declaration::varDecl

6 declaration::statement
               {
                declaration.returnType=statement.returnType;
               }

7 statement::breakStmt

8 statement::continueStmt

9 statement::returnStmt
             {
                statement.returnType=returnStmt.returnType;
             }

10 statement::exprStmt

11 statement::ifStmt
             {
                statement.returnType=ifStmt.returnType;
             }

12 statement::whileStmt
             {
                statement.returnType=whileStmt.returnType;
             }

13 statement::repeatStmt
             {
                statement.returnType=repeatStmt.returnType;
             }

14 statement::block
             {
                statement.returnType=block.returnType;
             }

15 statement::forStmt
             {
                statement.returnType=forStmt.returnType;
             }

16 breakStmt::BREAK SEMICOLON
              {
                irCode.push_back("goto {}");
                currentStmt.top().nextSentences.push(irCode.size()-1);
              }

17 continueStmt::CONTINUE SEMICOLON
                 {
                    irCode.push_back("goto {}");
                    currentStmt.top().code1Sentences.push(irCode.size()-1);
                 }

18 returnStmt::RETURN exprStmt
               {
                irCode.push_back("return {}",exprStmt.val);
                returnStmt.returnType=exprStmt.type;
               }


19 funDecl::IDENTIFIER
            {
                funDecl.id=IDENTIFIER;
                top.add(funDecl);
            }
            EQUAL FUNCTION LEFT_PAREN paramList RIGHT_PAREN block
            {
                returnType=block.returnType;
            }

20 varDecl::type
            {
                varDef.type=type.type;
                varDef.width=type.width;
            }
            varDef
            {
                varDefs.type=type.type;
                varDefs.width=type.width;
            }
            varDefs SEMICOLON

21 varDef::{var.usage=define;
           var.t=varDef.type;
           var.w=varDef.width;}
           var varInit
           {
                if(varInit.val)
                {
                    if(varInit.type==var.type)
                    {
                        top[var.id].value=varInit.val;
                    }
                    else
                    {
                        stop;
                    }
                    irCode.push_back("define {var.id} {var.type}");
                }
           }

22 varDefs1::COMMA 
             {
                varDef.type=varDefs1.type;
                varDef.width=varDefs1.width;
             }
             varDef
             {
                varDefs2.type=varDefs1.type;
                varDefs2.width=varDefs1.width;
             }
             varDefs2

23 varDefs::ε

24 varInit::EQUAL expression
            {
                varInit.val=expression.val;
                varInit.type=expression.type;
            }

25 varInit::ε

26 type::INTEGER
         {
            type.type=INTEGER;
            type.width=8;
         }

27 type::DOUBLE
         {
            type.type=DOUBLE;
            type.width=8;
         }

28 type::STRING
         {
            type.type=STRING;
            type.type=8;
         }

29 type::BOOL
         {
            type.type=BOOL;
            type.width=1;
         }

30 type::CHAR
         {
            type.type=CHAR;
            type.width=1;
         }

31 type::VAR
         {
            type.type=VAR;
            type.width=8;
         }

32 exprStmt::
             {
                 expression.jmp=exprStmt.jmp;
                 expression.trueJmp=exprStmt.trueJmp;
                 expression.falseJmp=exprStmt.falseJmp;
             }
             expression SEMICOLON
             {
                exprStmt.val=expression.val;
                exprStmt.returnType=expression.val;
             }

33 exprStmt::
             {
                 if(exprStmt.jmp)
                 {
                    irCode.push_back("goto {exprStmt.trueJmp}");
                    currentStmt.top().{exprStmt.trueJmp}Sentences.push(irCode.size()-1);
                 }
             }
             SEMICOLON
             {
                exprStmt.val=TRUE;
                exprStmt.returnType=NIL;
             }

34 ifStmt::{currentStmt.push(new(Statement));}
           IF LEFT_PAREN
           {
                expression.jmp=TRUE;
                expression.trueJmp=currentStmt.top().code1;
                expression.falseJmp=currentStmt.top().code2;
           }
           expression RIGHT_PAREN
           {
            currentStmt.top().code1=irCode.size();
           }
           statement
           {
            ifStmt.returnType=statement.returnType;
            irCode.push_back("goto {}");
            currentStmt.top().nextSentences.push(irCode.size()-1);
           }
           elseBranch
           {
            ifStmt.returnType=elseBranch.returnType;
            irCode.push_back("goto {}");
            currentStmt.top().nextSentences.push(irCode.size()-1);
            currentStmt.top().next=irCode.size();
            currentStmt.top().backpatch();
            currentStmt.pop();
           }

35 elseBranch::ELSE
               {
                    currentStmt.top().code2=irCode.size();
               }
               statement
               {
                    ifStmt.returnType=statement.returnType;
               }

36 elseBranch::{
                    currentStmt.top().code2=irCode.size();
               }
               ε      

37 whileStmt::{
                    currentStmt.push(new(Statement));
              }
              WHILE LEFT_PAREN
              {
                currentStmt.top().compare=irCode.size();
                currentStmt.top().code1=irCode.size();
                expression.jmp=TRUE;
                expression.trueJmp=currentStmt.top().code2;
                expression.falseJmp=currentStmt.top().next;

              }
              expression RIGHT_PAREN
              {
                currentStmt.top().code2=irCode.size();
              }
              statement
              {
                ifStmt.returnType=statement.returnType;
                irCode.push_back("goto {}")
                currentStmt.top().compareSentences.push(irCode.size()-1);
                currentStmt.top().next=irCode.size();
                currentStmt.top().backpatch();
                currentStmt.pop();
              }

38 forStmt::{
                currentStmt.push(new(Statement));
            }
            FOR LEFT_PAREN varDecl
            {
                currentStmt.top().compare=irCode.size();
                currentStmt.top().code1=irCode.size();
                exprStmt.jmp=TRUE;
                exprStmt.trueJmp=currentStmt.top().code2;
                exprStmt.falseJmp=currentStmt.top().next;
            }
            exprStmt RIGHT_PAREN
            {
                currentStmt.top().code2=irCode.size();
            }
            statement
            {
                ifStmt.returnType=statement.returnType;
                irCode.push_back("goto {}");
                currentStmt.top().code1Sentences.push(irCode.size()-1);
                currentStmt.top().next=irCode.size();
                currentStmt.top().backpatch();
                currentStmt.pop();
            }

39 forStmt::{
                currentStmt.push(new(Statement));
            }
            FOR LEFT_PAREN varDecl
            {
                currentStmt.top().compare=irCode.size();
                exprStmt.jmp=TRUE;
                exprStmt.trueJmp=currentStmt.top().code2;
                exprStmt.falseJmp=currentStmt.top().next;
            }
            exprStmt
            {
                currentStmt.top().code1=irCode.size();
            }
            expression RIGHT_PAREN
            {
                
                irCode.push_back("goto {}");
                currentStmt.top().compareSentences.push(irCode.size()-1);
                currentStmt.top().code2=irCode.size();
            }
            statement
            {
                ifStmt.returnType=statement.returnType;
                irCode.push_back("goto {}");
                currentStmt.top().code1Sentences.push(irCode.size()-1);
                currentStmt.top().next=irCode.size();
                currentStmt.top().backpatch();
                currentStmt.pop();
            }

40 forStmt::{
                currentStmt.push(new(Statement));
            }
            FOR LEFT_PAREN exprStmt1
            {
                currentStmt.top().compare=irCode.size();
                currentStmt.top().code1=irCode.size();
                exprStmt2.jmp=TRUE;
                exprStmt2.trueJmp=currentStmt.top().code2;
                exprStmt2.falseJmp=currentStmt.top().next;
            }
            exprStmt2 RIGHT_PAREN
            {
                currentStmt.top().code2=irCode.size();
            }
            statement
            {
                ifStmt.returnType=statement.returnType;
                irCode.push_back("goto {}")
                currentStmt.top().code1Sentences.push(irCode.size()-1);
                currentStmt.top().next=irCode.size();
                currentStmt.top().backpatch();
                currentStmt.pop();
            }

41 forStmt::{
                currentStmt.push(new(Statement));
            }
            FOR LEFT_PAREN exprStmt1
            {
                currentStmt.top().compare=irCode.size();
                exprStmt2.jmp=TRUE;
                exprStmt2.trueJmp=currentStmt.top().code2;
                exprStmt2.falseJmp=currentStmt.top().next;
            }
            exprStmt2
            {
                currentStmt.top().code1=irCode.size();
            }
            expression RIGHT_PAREN
            {
                irCode.push_back("goto {}");
                currentStmt.top().compareSentences.push(irCode.size()-1);
                currentStmt.top().code2=irCode.size();
            }
            statement
            {
                ifStmt.returnType=statement.returnType;
                irCode.push_back("goto {}");
                currentStmt.top().code1Sentences.push(irCode.size()-1);
                currentStmt.top().next=irCode.size();
                currentStmt.top().backpatch();
                currentStmt.pop();
            }

42 block::LEFT_BRACE declarations RIGHT_BRACE
          {
            block.returnType=declarations.returnType;
          }

43 repeatStmt::{
                    currentStmt.push(new(Statement));
               }
               REPEAT
               {
                    currentStmt.top().code2=irCode.size();
               }
               statement
               {
                    ifStmt.returnType=statement.returnType;
                    irCode.push_back("goto {}");
                    currentStmt.top().compareSentences.push(irCode.size()-1);
               }
               UNTIL LEFT_PAREN
               {
                    currentStmt.top().compare=irCode.size();
                    expression.jmp=TRUE;
                    expression.trueJmp=currentStmt.top().code2;
                    expression.falseJmp=currentStmt.top().next;
               }
               expression RIGHT_PAREN SEMICOLON
               {
                    currentStmt.top().next=irCode.size();
                    currentStmt.top().backpatch();
                    currentStmt.pop();
               }


44 paramList::parameter parameters
45 paramList::ε
46 parameters::COMMA parameter parameters
47 parameters::ε
48 parameter::type
              {
                    var.usage=define;
                    var.t=type.type;
                    var.w=type.width;
              }
              var


49 expression::
               {
                    assignment.jmp=expression.jmp;
                    assignment.trueJmp=expression.trueJmp;
                    assignment.falseJmp=expression.falseJmp;
               } 
               assignment
               {
                expression.val=assignment.val;
                expression.type=assignment.type;
               }

50 assignment::var EQUAL assignment
                {
                    tmp1=autoConversion(assignment.val,assignment.type,var.type);
                    irCode.push_back("{var.val}={tmp1}");
                    assignment.val=var.val;
                    assignment.type=var.type;
                    if(assignment.jmp)
                    {
                        irCode.push_back("if {var.val}!=0 goto {}");
                        currentStmt.top().{assignment.trueJmp}Sentences.push(irCode.size()-1);
                        irCode.push_back("goto {assignment.falseJmp}");
                        currentStmt.top().{assignment.falseJmp}Sentences.push(irCode.size()-1);
                    }
                }

51 assignment::
               {
                    logic_or.jmp=assignment.jmp;
                    logic_or.trueJmp=assignment.trueJmp;
                    logic_or.falseJmp=assignment.falseJmp;
               }
               logic_or
               {
                assignment.val=logic_or.val;
                assignment.type=logic_or.type;
               }

52 logic_or::
             {
                currentExpr.push(new(Expression));
                logic_and.jmp=logic_or.jmp;
                logic_and.trueJmp=logic_or.trueJmp;
                logic_and.falseJmp=currentExpr.top().right;
                logic_or_prime.jmp=logic_or.jmp;
                logic_or_prime.trueJmp=logic_or.trueJmp;
                logic_or_prime.falseJmp=logic_or.falseJmp;
             }
             logic_and
             {
                currentExpr.top().right=irCode.size();
             }
             logic_or_prime
               {
                    if(logic_or_prime.op=="||")
                    {
                        tmpT=autoConversion(logic_and.val,logic_and.type,logic_or_prime.val,
                            logic_or_prime.type,logic_or_prime.op);
                        logic_or.val=tmpT;
                        logic_or.type=BOOL;
                    }
                    else
                    {
                        if(logic_or_prime.jmp)
                        {
                            irCode.push_back("goto {}");
                            logic_or.trueJmp.push_back(irCode.size()-1);
                        }
                        logic_or.val=logic_and.val;
                        logic_or.type=logic_and.type;
                    }
                    currentExpr.top().backpatch;
                    currentExpr.pop();
               }

53 logic_or_prime::OR
                   {
                        logic_or.jmp=logic_or_prime.jmp;
                        logic_or.trueJmp=logic_or_prime.trueJmp;
                        logic_or.falseJmp=logic_or_prime.falseJmp;
                   }
                   logic_or
                   {
                        logic_or_prime.op="||";
                        logic_or_prime.val=logic_or.val;
                        logic_or_prime.type=logic_or.type;
                   }

54 logic_or_prime::ε

55 logic_and::
              {
                    currentExpr.push(new(Expression));
                    logic_and_prime.jmp=logic_and.jmp;
                    logic_and_prime.trueJmp=logic_and.trueJmp;
                    logic_and_prime.falseJmp=logic_and.falseJmp;
              }
              equality
              {
                if(logic_and.jmp)
                {
                    irCode.push("if {equality.val} goto {}");
                    currentExpr.top().rightSentences.push(irCode.size()-1);
                    irCode.push("goto {}");
                    logic_and.falseJmp.push_back(irCode.size()-1);
                }
                currentExpr.top().right=irCode.size();
              }
              logic_and_prime
                   {
                        if(logic_and_prime.op=="&&")
                        {
                            tmpT=autoConversion(equality.val,equality.type,logic_and_prime.val,
                                logic_and_prime.type,logic_and_prime.op);
                            logic_and.val=tmpT;
                            logic_and.type=BOOL;
                            if(logic_and.jmp)
                            {
                                irCode.push("if {logic_and_prime.val} goto {}");
                                logic_and.trueJmp.push_back(irCode.size()-1);
                                irCode.push("goto {}");
                                logic_and.falseJmp.push_back(irCode.size()-1);
                            }
                        }
                        else
                        {
                            logic_and.val=equality.val;
                            logic_and.type=equality.type;
                            if(logic_and.jmp)
                            {
                                irCode.push_back("goto {}");
                                logic_and_prime.trueJmp.push_back(irCode.size()-1);
                            }
                        }
                    currentExpr.top().backpatch;
                    currentExpr.pop();
                   }

56 logic_and_prime::AND
                    {
                        logic_and.jmp=logic_and_prime.jmp;
                        logic_and.trueJmp=logic_and_prime.trueJmp;
                        logic_and.falseJmp=logic_and_prime.falseJmp;
                    }
                    logic_and
                    {
                        logic_and_prime.op="&&";
                        logic_and_prime.val=logic_and.val;
                        logic_and_prime.type=logic_and.type; 
                    }

57 logic_and_prime::ε

58 equality::comparison equality_prime
                   {
                        if(equality_prime.op=="!=" || equality_prime.op=="==")
                        {
                            tmpT=autoConversion(comparison.val,comparison.type,equality_prime.val,equality_prime.type,equality_prime.op);
                            equality.val=tmpT;
                            equality.type=BOOL;
                        }
                        else
                        {
                            equality.val=comparison.val;
                            equality.type=comparison.type;
                        }
                   }

59 equality_prime::NOT_EQUAL equality
                   {
                    equality_prime.op="!=";
                    equality_prime.val=equality.val;
                    equality_prime.type=equality.type;
                   }

60 equality_prime::EQUAL_EQUAL equality
                   {
                    equality_prime.op="==";
                    equality_prime.val=equality.val;
                    equality_prime.type=equality.type;
                   }

61 equality_prime::ε

62 comparison::term comparison_prime
               {
                if(comparison_prime.op==">" || comparison_prime.op==">=" || comparison_prime.op=="<"|| comparison_prime.op=="<=")
                {
                    tmpT=autoConversion(term.val,term.type,comparison_prime.val,comparison_prime.type,
                                        comparison_prime.op);
                    comparison.val=tmpT;
                    comparison.type=BOOL;
                }
                else
                {
                    comparison.val=term.val;
                    comparison.type=term.type;
                }
               }

63 comparison_prime::GREATER comparison
                     {
                        comparison_prime.op=">";
                        comparison_prime.val=comparison.val;
                        comparison_prime.type=comparison.type;
                     }

64 comparison_prime::GREATER_EQUAL comparison
                     {
                        comparison_prime.op=">=";
                        comparison_prime.val=comparison.val;
                        comparison_prime.type=comparison.type;
                     }

65 comparison_prime::LESS comparison
                     {
                        comparison_prime.op="<";
                        comparison_prime.val=comparison.val;
                        comparison_prime.type=comparison.type;
                     }

66 comparison_prime::LESS_EQUAL comparison
                     {
                        comparison_prime.op="<=";
                        comparison_prime.val=comparison.val;
                        comparison_prime.type=comparison.type;
                     }

67 comparison_prime::ε

68 term::factor term_prime
         {
            if(term_prime.op=='+' || term_prime.op=='-')
            {
                tmpT,tmpType=autoConversion(factor->val,factor->type,term_prime->val,term_prime->type,term_prime->op);
                term.val=tmpT;
                term.type=tmpType;
            }
            else
            {
                term.val=factor.val;
                term.type=factor.type;
            }
         }       

69 term_prime::MINUS term
               {term_prime.op="-";
               term_prime.val=term.val;
               term_prime.type=term.type;}

70 term_prime::PLUS term
               {term_prime.op="+";
               term_prime.val=term.val;
               term_prime.type=term.type;}

71 term_prime::ε

72 factor::incr_exp factor_prime
           {
            if(factor_prime.op=="/" || factor_prime.op=="*" || factor_prime.op=="%")
            {
                tmpT,tmpType=autoConversion(incr_exp.val,incr_exp.type,
                    factor_prime.val,factor_prime.type,factor_prime.op);
                factor.val=tmpT;
                factor.type=tmpType;
            }
            else
            {
                factor.val=incr_exp.val;
                factor.type=incr_exp.type;
            }
           }

73 factor_prime::DIV factor
                 {factor_prime.op="/";
                 factor_prime.val=factor.val;
                 factor_prime.type=factor.type;}

74 factor_prime::STAR factor
                 {factor_prime.op="*";
                 factor_prime.val=factor.val;
                 factor_prime.type=factor.type;}

75 factor_prime::MOD factor
                 {factor_prime.op="%";
                 factor_prime.val=factor.val;
                 factor_prime.type=factor.type;}

76 factor_prime::ε

77 incr_exp::unary
            incr_op
             {
                if(!incr_op.ifused)
                {
                    incr_exp.val=unary.val;
                    incr_exp.type=unary.type;
                }
                else
                {
                    if(incr_op.val>0)
                    {
                        op="+";
                    }
                    else
                    {
                        op="-";
                    }
                    num=|-incr_op.val|.to_string;
                    tmpT,tmpType=autoConversion(unary.val,unary.type,num,INTEGER,op);
                    incr_exp.val=tmpT;
                    incr_exp.type=tmpType;
                }
             }

78 incr_op1::DOUBLE_ADD incr_op2
             {
                incr_op1.ifused=true;
                incr_op1.val=incr_op2.val+1;
             }

79 incr_op1::DOUBLE_MINUS incr_op2
             {
                incr_op1.ifused=true;
                incr_op1.val=incr_op2.val-1;
             }

80 incr_op::ε
            {
                incr_op.ifused=false;
                incr_op.val=0;
            }

81 unary1::NOT unary2
           {
            tmpT1=autoConversion(unary2.val,unary2.type,BOOL);
            tmpT2=genT();
            irCode.push_back("{tmpT2}=!{tmpT1}");
            unary1.val=tmpT2;
            unary1.type=BOOL;
           }
           
82 unary1::MINUS unary2
           {
                if(unary2.type<INTEGER)
                {
                    tmpT1=genT();
                    irCode.push_back("{tmpT1}=(interger){unary2.val}");
                    tmpT2=genT();
                    irCode.push_back("{tmpT2}=-{tmpT1}");
                    unary1.val=tmpT2;
                    unary1.type=INTEGER;
                }
                else
                {
                    tmpT1=genT();
                    irCode.push_back("{tmpT1}=-{unary2.val}");
                    unary1.val=tmp1;
                }
           }
83 unary::call
          {unary.val=call.val;
          unary.type=call.type;}


84 call::primary {call_suffix.callee=primary.val;}
         call_suffix
         {
            if(call_suffix.exist)
            {
                call.val=call_suffix.val;
                call.type=call_suffix.type;
            }
            else
            {
                call.val=primary.val;
                call.type=primary.type;
            }
         }

85 call_suffix1::LEFT_PAREN argList RIGHT_PAREN
                {tmpT1=genT();
                irCode.push_back("{tmpT1}=call {call_suffix1.callee},{argList.sum}");
                call_suffix2.callee=tmpT1;}
                call_suffix2
                {
                    call_suffix1.exist=true;
                    call_suffix1.type=top[call_suffix1.callee].returnType;
                    if(call_suffix2.exist)
                    {
                        call_suffix1.val=call_suffix2.val;
                        call_suffix1.type.call_suffix2.type;
                    }
                    else
                    {
                        call_suffix1.val=tmpT1;
                    }
                }

86 call_suffix::ε
               {call_suffix.exist=false;}

87 argList::expression
            {irCode.push_back("param {expression.val}");}
            arguments
            {argList.sum=1+arguments.sum;}

88 argList::ε
            {argList.sum=0;}

89 arguments1::COMMA expression
               {irCode.push_back("param {expression.val}");}
               arguments2
               {arguments1.sum=1+arguments2.sum;}
90 arguments::ε
              {arguments.sum=0;}

91 primary::constVal
            {primary.val=constVal.val;
            primary.type=constVal.type;}

92 primary::LEFT_PAREN expression RIGHT_PAREN
            {primary.val=expression.val;
            primary.type=expression.type;}

93 primary::{var.usage=reference;}
            var
            {primary.val=var.val;
            primary.type=var.type;}

94 constVal::TRUE
             {constVal.val=TRUE.Lexeme;
             constVal.type=BOOL;}

95 constVal::FALSE
             {constVal.val=FALSE.Lexeme;
             constVal.type=BOOL;}

96 constVal::NIL
             {constVal.val=NIL.Lexeme;
             constVal.type=NIL;}

97 constVal::INT_
             {constVal.val=INT_.Lexeme;
             constVal.type=INTEGER;}

98 constVal::REAL_
             {constVal.val=REAL_.Lexeme;
             constVal.type=DOUBLE;}

99 constVal::STRING_
             {constVal.val=STRING_.Lexeme;
             constVal.type=STRING;}

100 var::IDENTIFIER
         {
            if (var.usage==define)
            {
                var.id=IDENTIFIER;
                varSuffix.usage=var.usage;
                varSuffix.t=var.t;
                varSuffix.w=var.w;
            }
            else if(var.usage==reference)
            {
                var.id=IDENTIFIER;
                var.type=top[var.id].type;
                varSuffix.usage=var.usage;
                varSuffix.type=var.type;
                varSuffix.length=varSuffix.type.length;
            }
            
          }
         varSuffix
         {
            if (var.usage==define)
            {
                var.type=varSuffix.type;
                var.width=varSuffix.width*varSuffix.length;
                top.add(var);
            }
            else if(var.usage==reference)
            {
                var.offset=varSuffix.offset;
                if(var.offset==0)
                {
                    var.val=var.id;
                }
                else
                {
                    tmp1=genT();
                    irCode.push_back("{tmp1}={var.id}+{var.offset}");
                    var.val=tmp1;
                }
                var.type=varSuffix.returnType;
            }
         }
         
101 varSuffix::LEFT_BRACKET expression RIGHT_BRACKET
               {
                    if (varSuffix.usage==define)
                    {
                        varSuffix1.usage=varSuffix.usage;
                        varSuffix1.t=varSuffix.t;
                        varSuffix1.w=varSuffix.w;
                    }
                    else if(varSuffix.usage==reference)
                    {
                        varSuffix.len=expression.val;
                        varSuffix1.usage=varSuffix.usage;
                        varSuffix1.type=varSuffix.type.type;
                        varSuffix1.length=varSuffix1.type.length;
                    }
               }
               varSuffix1
               {
                    if (varSuffix.usage==define)
                    {
                        varSuffix.length=expression.val;
                        varSuffix.width=varSuffix1.width*varSuffix1.length;
                        varSuffix.type=array(varSuffix.length,varSuffix1.type);
                       
                    }
                    else if(varSuffix.usage==reference)
                    {
                        varSuffix.width=varSuffix1.width*varSuffix1.length;
                        varSuffix.offset=varSuffix1.offset+varSuffix.len*varSuffix.width;
                        varSuffix.returnType=varSuffix1.returnType;
                    }
               }
               
102 varSuffix::ε
               {
                    if (varSuffix.usage==define)
                    {
                        varSuffix.length=varSuffix.t.length;
                        varSuffix.type=varSuffix.t;
                        varSuffix.width=varSuffix.w;
                    }
                    else if(varSuffix.usage==reference)
                    {
                        varSuffix.width=varSuffix.type.length;
                        varSuffix.offset=0;
                        varSuffix.returnType=varSuffix.type;
                    }
               }